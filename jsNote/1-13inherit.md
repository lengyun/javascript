# 继承

回顾：

js创建对象的几中模式，工厂模式，构造函数模式，原型模式，组合模式等

所有的函数上都有一个特殊的属性叫做 prototype，这个prototype指向的是一个对象这个对象我们称之为原型对象。而在这个原型对象上默认只有一个属性叫constructor，这个constructor又指向了这个构造函数。形成一个闭环。

所有的对象上都有个隐藏属性叫做proto ，这个proto正常是访问不到的，在现在浏览器上可以使用`__proto__` 访问。这个proto指向了当前这个对象他所对应的构造函数所对应的原型对象。当你去访问一个对象上的属性的时候，首先会去看这个对象上有没有这个属性，有这个属性就直接调用或访问，没有的话解释器就会顺着proto找到对应的原型对象看看原型对象上有没有这个属性。如果有就直接调用原型对象上的属性，如果原型对象上没有，那么原型对象本身也是一个对象它的上面也有一个proto的隐藏属性，这时解释器会顺着这个proto接着往它上一层找到它所对应的原型对象，依次的去往上查找。我们也把每一个对象上所对应的proto链接成的这一条线路称之为**原型链**。我们去访问对象上的每一个属性的时候，都会顺着原型链依次往上去访问，原型链的最后指向一个null这么一个特殊的东西。

如果设置的话，比如给对象添加一个属性或者给一个属性赋值，这个时候会在当前这个对象上直接添加属性或直接把当前对象上的属性改掉。

------

面向对象

在整个语言当中会有很多的类，类和类之间存在继承关系。

面向过程 

-----

js本身是通过函数累加来实现的，也被称作面向过程的语言。 不存在面向对象的思想，只不过可以模拟出来。 

**继承** 马里奥游戏举例

##原型链继承

假设有两个构造函数A和B，让B的实例可以使用A的属性或者方法怎么做？

当你使用 new B去创建B的实例的时候，如果你去使用这个实例上的属性和方法，这个时候会去看这个实例上有没有这个属性和方法。如果没有会到这个实例对应的原型对象上继续去找。那么现在的任务是要让它没有的时候去A上找，此时我们可以让B这个构造函数所对应的原型对象去指向A的实例如下：

```js
B.prototype = new A()
```

接下来我们去创建B的实例的时候：当我们去访问B的实例bb上的属性和方法的时候，首先去看实例bb上有没有这个属性和方法，如果没有就去B这个构造函数的原型对象上找，这时B的构造函数原型对象已经变成A的实例了，相当于去A的实例上去找，A的实例上也没有这个时候怎么办 

优点：**

1. 使用简单。
2. 当我们使用这行代码后接着在b的prototype上增加属性和方法的时候子类都可以访问的到。

---

如果使用 `b.prototype = a.prototype ` 也可以，但在b中增加属性和方法的时候，就会直接增加到a的原型对象上，破坏了a的原型对象